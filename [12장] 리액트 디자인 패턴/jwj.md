# 12장 리액트 디자인 패턴

- 고차 컴포넌트 패턴
- 렌더링 Props 패턴
- Hooks 패턴
- 정적 가져오기
- 동적 가져오기
- 코드 스플리팅
- PRPL 패턴
- 로딩 우선순위

# 고차 컴포넌트

여러 컴포넌트에 동일한 로직을 적용하고 싶을 때 사용한다.

### 장점

재사용 로직을 한 곳에 모아서 관리할 수 있다.

### 단점

1. props 이름이 충돌을 일으킬 수 있다.
2. 복잡성이 증가할 수 있다. 여러 고차 컴포넌트를 조합해서 사용하면 디버깅이 어려워질 수 있다.

# 렌더링 Props 패턴

컴포넌트를 재사용할 수 있는 패턴이다.

렌더링 prop은 JSX 요소를 반환하는 함수 값을 가지는 컴포넌트의 prop이다. 컴포넌트는 렌더링 prop 외에 아무것도 렌더링하지 않는다.

prop 이름은 `render`일 필요가 없으며 JSX를 렌더링하는 모든 prop은 렌더링 prop으로 간주된다.

## 상태 끌어올리기

형제 컴포넌트 간에 상태를 공유해야 할 때가 있다. 작은 규모의 애플리케이션의 경우, 전역 상태 관리 라이브러리 대신 해당 패턴을 사용할 수 있다.

하지만 상태 변경 시 데이터를 사용하지 않는 자식 컴포넌트까지 모두 리렌더링될 수 있는 단점이 있다. 이 문제를 렌더링 Props 패턴으로 해결할 수 있다.

### 장점

1. 여러 컴포넌트 사이에 로직과 데이터를 쉽게 공유할 수 있다.
2. 고차 컴포넌트의 props 이름 충돌 문제를 해결할 수 있다.

### 단점

1. 대부분의 경우 hook을 사용하는 것으로 대체할 수 있다.
2. 라이프사이클 관련 메서드를 추가할 수 없어, 받은 데이터를 그저 보여주기만 하는 컴포넌트에만 사용할 수 있다.

# Hooks 패턴

함수 컴포넌트에서 상태와 라이프사이클을 관리할 수 있게 해주는 기능이다.

훅은 기존의 클래스 컴포넌트의 복잡한 상태, 라이프사이클 관리를 편하게 사용할 수 있게 했다. 또한, 고차 컴포넌트나 렌더링 Props 패턴을 사용할 때, 패턴 추가를 위해 구조를 변경해야 하는 수고를 덜어준다.

# 정적 가져오기

`import` 키워드로 다른 모듈에서 내보낸 코드를 가져올 수 있다. 기본적으로 정적으로 가져오는 모든 모듈은 초기 번들에 추가된다.

따라서 무거운 모듈은 코드 스플리팅을 통해 동적으로 가져와서 초기 번들 크기를 줄이는 최적화가 필요하다.

# 동적 가져오기

리액트의 `Suspense` 컴포넌트를 사용하면 동적으로 로딩할 수 있다.

SSR 환경에서는 아직 `Suspense`를 지원하지 않지만, 그 대안으로 `loadable-components` 라이브러리가 있다. 최대한 CSR 환경에서의 `Suspense` 사용법과 비슷하게 지연 로딩을 구현할 수 있게 한다.

상호작용 시 가져오기, 화면에 보이는 순간 가져오기(IntersectionObserver API, `react-loadable-visibility`, `react-lazyload` 등) 구현할 수 있는 방법이 있다.

# 코드 스플리팅

경로 기반 분할, 웹팩이나 롤업 등 번들러를 사용해 소스 코드를 분할하고 번들링하는 최적화 방법이다.

## 경로 기반 분할

경로 기반 분할은 특정 경로에 따라 필요한 리소스만 요청하여 번들 크기를 줄이는 기법이다. `Suspense`와 함께 사용하면 경로에 따라 컴포넌트를 동적으로 로드할 수도 있다.

# PRPL 패턴

Push Render Pre-cache Lazy-load의 준말이다. 초기 로딩 최적화에 중점을 둔 패턴이다.

- Push: 중요한 리소스를 효율적으로 푸시
- Render: 초기 경로를 최대한 빠르게 렌더링
- Pre-cache: 자주 방문하는 경로의 에셋을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄임
- Lazy-load: 자주 요청되지 않는 경로나 에셋은 지연 로딩

## HTTP 통신

### HTTP/1.1

- keep-alive 헤더로 TCP 연결 유지
- 줄바꿈으로 구분되는 일반 텍스트 프로토콜
- 최대 6개의 TCP 연결(HOL Blocking)

### HTTP/2

- 요청과 응답을 헤더 프레임, 데이터 프레임으로 분할
- 양방향 스트림 지원
- 이전 요청 완료 전 동일한 TCP 연결로 여러 요청 가능(HOL Blocking 해결)
- 데이터를 매번 전송하지 않고 서버가 리소스를 푸시하여 자동으로 추가 리소스를 전송 가능(서버 푸시)

서버 푸시는 HTTP 캐시를 인지하지 못해 **PRPL 패턴에서는 초기 로드 후 서비스 워커를 사용**해 해당 리소스를 캐시한다.

> HTTP/2 서버 푸시 기능은 크롬 106부터 비활성화되었고, 파이어폭스도 마찬가지다. 관련 글은 https://developer.chrome.com/blog/removing-push?hl=ko를 참조.

# 로딩 우선순위

빠른 로딩이 필요한 리소스를 선제적으로 로드하는 것을 의미한다.

`<link rel="preload">`는 리소스를 일찍 요청할 수 있게 해준다. 하지만, FCP, LCP에 필요한 폰트나 배경 이미지의 로딩이 지연되지 않도록 주의해야 한다.

- `preload`: 어떤 상황에서든 무조건 미리 로드
- `prefetch`: 브라우저가 연결 상태, 대역폭을 고려해 어떤 리소스를 미리 가져올지 결정

## Preload + async

스크립트를 우선 다운로드하면서, 파싱을 멈추지 않게끔 하는 방법이다.

```html
<link rel="preload" href="what.js" as="script" />
<script src="what.js" async></script>
```

다른 리소스 다운로드의 지연이 발생할 수 있으므로 주의한다.

## preload 권장 사항

- HTTP 헤더에 preload를 넣으면 다른 모든 리소스보다 우선적으로 로드됩니다.
- 일반적으로 중간 레벨(Medium) 이상의 우선순위를 가진 preload는 파서가 HTML을 처리하는 순서대로 로드되므로, HTML 시작 부분에 preload를 넣을 때 주의해야 합니다.
- 미리 로드되는 폰트는 `<head>` 태그 끝 부분이나 `<body>` 태그 시작 부분에 넣는 것이 가장 좋습니다.
- 미리 로드되는 모듈을 가져오는 건 실제 스크립트가 먼저 로드/파싱되도록, 해당 가져오기가 필요한 `<script>` 태그 다음에 위치해야 합니다.
- 이미지 preload는 기본적으로 우선순위가 낮으며, 비동기 스크립트 및 기타 낮은/최저 우선순위 태그와 관련하여 순서를 지정해야 합니다.

# 리스트 가상화

대규모 데이터 리스트의 렌더링 성능을 향상시키는 방법이다. 전체 목록을 모두 렌더링하지 않고 현재 화면에 보이는 행만 동적으로 렌더링한다.

`react-visualized`, `react-window` 같은 라이브러리로 구현할 수 있다.

최신 브라우저는 CSS의 `content-visibility` 속성을 지원하며, 값을 `auto`로 설정하면 화면 밖 콘텐츠의 렌더링과 페인팅을 필요한 시점까지 지연할 수 있다.
