# 8장 자바스크립트 MV* 패턴

## 8.1 MVC 패턴

- 비즈니스 데이터(모델)과 UI(뷰)를 분리하고, 세 번째 구성요소(컨트롤러)가 로직과 사용자 입력을 관리하는 구조
- 과거의 MVC 패턴
    - 모델 : 도메인 관련 데이터를 표현했으며 UI에 대해서는 관여하지 않았습니다. 모델이 변경되면 자신의 관찰자 객체에게 알림을 보냄
    - 뷰 : 모델의 현재 상태를 표현했습니다. 관찰자 패턴을 사용해 모델이 변경되거나 수정될 때마다 뷰가 알아차릴 수 있도록 함
    - 컨트롤러 : 사용자의 상호작용을 처리하고 뷰에 무엇을 보여줄지 등을 결정하는 역할

## 8.2 자바스크립트의 MVC

![image.png](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20MV%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20243f78a2bff1801ab707fd42eecaead0/image.png)

- 모델
    - 애플리케이션의 데이터를 관리하는 역할
    - UI나 프레젠테이션 계층은 담당하지 않고, 애플리케이션에 필요한 고유 데이터 형식을 나타냄
    - 모델이 변경될 때 관찰자에게 변경사항을 알려서 관찰자가 변경된 내용에 알맞게 능동적으로 대응할 수 있게끔 함
- 뷰
    - 모델에 대한 시각적인 표현으로 현재 상태의 특정 부분만 보여줌.
    - 자바스크립트의 뷰는 여러 DOM 요소의 집합을 생성하고 정리하는 역할을 함
    - 일반적으로 모델을 관찰하고 모델에 변화가 생기면 알림을 받음. 이를 통해 뷰는 스스로를 업데이트할 수 있음
    - 사용자는 뷰와 상호 작용할 수 있으며 모델의 데이터를 읽고 수정하는 기능도 포함됨
    - 뷰는 프레젠테이션 계층이기 때문에 사용자와 상호 작용하는 기능(편집이나 업데이트)를 유저 친화적으로 제공함
- 템플릿
    - 템플릿은 "데이터를 시각적으로 표현하기 위한 틀" 이며, 사용자가 보는 화면을 구성하기 위해 모델의 데이터를 HTML 형태로 변환하는 역할을 한다.
    - 템플릿 자체가 뷰는 아니고 뷰 객체의 일부 또는 전체를 선언적으로 지정할 수 있는 방법이 될 수 있다.
    - 뷰는 애플리케이션 데이터를 시각적으로 표현하고, 템플릿은 뷰를 생성하기 위해 사용될 수 있다.
    - 태그 템플릿 리터럴 같은 최신 템플릿 기법은 자바스크립트 애플리케이션에서 동적인 HTML 콘텐츠를 깔끔하고 유지보수가 용이한 방식으로 만들 수 있도록 해준다.
- 컨트롤러
    - 모델과 뷰 사이의  중재자 역항르 하며, 일반적으로 사용자가 뷰를 조작할 때 모델을 업데이트하는 역할을 한다.
    - 컨트롤러는 애플리케이션 내에서 모델과 뷰 간의 로직과 연동을 관리한다.

## 8.3 MVC를 사용하는 이유는?

- MVC에서의 관심사 분리는 애플리케이션의 기능을 더 간단한 모듈로 나눌 수 있도록 해준다.
- 전반적인 유지보수의 단순화 : 애플리케이션을 업데이트해야 할 때, 변경 사항이 데이터 중심인지 단순히 시각적인 변경인지 명확하게 구분할 수 있다.
- 모델과 뷰의 분리 : 비즈니스 로직에 대한 단위 테스트의 작성이 훨씬 간편해짐

## 8.4 자바스크립트와 Smalltalk-80의 MVC

- Smalltalk-80에서 찾을 수 있는 패턴은 순수한 형태를 고수하려는 프레임 워크도 있다.
(MVC의 근본에 충실한 구현을 제시하는 등)

## 8.6 MVP 패턴

![image.png](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20MV%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20243f78a2bff1801ab707fd42eecaead0/image%201.png)

- 모델, 뷰, 프리젠터
    - 프리젠터는 뷰에 대한 UI 비즈니스 로직을 담당하는 구성요소다. MVC와 달리, 뷰에서의 이벤트 호출은 프리젠터로 위임된다.
    - 프리젠터는 뷰와 분리되어 있으며, 인터페이스를 통해 뷰와 통신한다.
    - 뷰의 요청에 따라, 프리젠터는 사용자 요청과 관련된 작업을 수행하고 데이터를 뷰로 다시 전달한다. 이를 위해 프리젠터는 데이터를 가져오고, 조작하고, 이 데이터가 어떻게 뷰에 표시되어야 하는지 결정한다.
- MVP vs MVC
    - MVP는 일반적으로 프레젠테이션 로직을 최대한 재사용해야하는 엔터프라이즈 수준의 애플리케이션에서 사용됨.
    - 뷰가 복잡하고 상호작용이 많은 경우 MVP가 적합할 수 있음(복잡한 로직을 프리젠터 안에 캡슐화할 수 있기 때문)
    - MVP의 뷰는 인터페이스를 통해 정의되고 인터페이스가 시스템과 뷰 간의 유일한 접점이므로 이 패턴을 통해 디자인이 완성되지 않아도 프레젠테이션 로직을 작성할 수 있음
    - MVP가 MVC 보다 단위 테스트가 더 쉬울 수 있음 (프리젠터를 UI의 완전한 모킹으로 사용하여 다른 구성 요소와 독립적으로 단위 테스트를 할 수 있기 때문)

## 8.7 MVVM 패턴

- 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리함
- 구성 요소
    - 모델 : 도메인에 관련된 정보를 전달
    - 뷰 : 사용자 인터페이스(UI)
    - 뷰모델 : 모델과 뷰 사이의 인터페이스 역할을 함
- 모델
    - 다른 MV* 패턴과 마찬가지로 애플리케이션이 사용할 도메인 관련 데이터나 정보를 제공함
    - 보통 정보를 담고있고, 동작을 다루지 않음
- 뷰
    - 수동적 뷰 : 단순히 화면을 출력할 뿐 사용자의 입력을 받아들이지 않음
    - 능동적 뷰 (MVVM) : 데이터 바인딩, 이벤트, 동작들을 포함하고 있음.
- 뷰 모델
    - 데이터 변환기의 역항르 하는 특수한 컨트롤러
    - 모델의 정보를 뷰가 사용할 수 있는 형태로 변환하고, 뷰에서 발생한 명령을 모델로 전달함
    - 뷰라기보다는 모델에 더 가깝지만 동시에 뷰의 디스플레이 로직 대부분을 처리함
    - 뷰 모델은 UI 계층의 뒤에 위치하여 뷰가 필요로 하는 데이터를 제공하며, 데이터와 사용자의 동작 모두를 뷰가 참조하는 출처의 역할을 할 수 있음
- 뷰모델 vs 모델
    - MVVM에서 뷰 모델은 모델에 대한 전적인 책임을 지지만, 뷰모델은 데이터 바인딩을 위해 모델 또는 모델의 속성을 가져올 수 있고, 뷰에 제공되는 속성을 가져오거나 조작하기 위한 인터페이스를 포함할 수 있음
- 장점
    - MVVM은 UI와 이를 구동하게 해주는 요소를 동시에 개발할 수 있도록 함
    - MVVM은 뷰를 추상화함으로써 뷰의 뒤에 작성되는 비즈니스 로직의 양을 줄여줌
    - 뷰모델은 이벤트 중심 코드에 비해 단위 테스트가 더 쉬움
    - 뷰모델은 UI 자동화나 상호작용에 대한 고려없이도 테스트가 가능함
- 단점
    - 단순한 UI의 경우, MVVM은 과도한 구현이 될 수 있음
    - 데이터 바인딩은 선언적이고 사용하기 편리할 수 있지만 디버깅이 어려울 수 있음

## 8.9 MVC vs MVP vs MVVM

- MVC에서는 뷰가 아키텍처의 최상단에 위치하고 그 옆에는 컨트롤러가 있음. 모델은 컨트롤러 아래에 있기에 뷰는 컨트롤러에 대해 알고 있고, 컨트롤러는 모델에 대해 알고 있음. 이 구조에서 뷰는 모델에 직접 접근할 수 있지만 전체 모델을 뷰에 노출하는 것은 애플리케이션의 복잡도에 따라 보안 및 성능에 문제를 일으킴
(MVVM은 이를 피하기 위한 패턴)
- MVP에서는 컨트롤러의 역할이 프리젠터로 대체됨. 프리젠터는 뷰와 동일한 계층에 존재하며, 뷰와 모델 양쪽에서 발생하는 이벤트를 수신하고 이들 간의 동작을 조정함. MVVM과 달리 뷰와 뷰모델을 바인딩하는 메커니즘이 없기에 각 뷰는 프리젠터가 뷰와 상호작용할 수 있도록 인터페이스를 구현함
- MVVM을 사용하면 상태와 로직 정보를 포함할 수 있는 뷰와 관련된 모델 일부를 생성할 수 있음. 이를 통해 전체 모델을 뷰에 노출하는 것을 피할 수 있음