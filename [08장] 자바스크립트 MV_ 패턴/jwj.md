# 8장 자바스크립트 MV\* 패턴

애플리케이션 설계는 객체의 설계, 애플리케이션 아키텍처 설계의 두 측면이 있다.

- MVC
- MVP
- MVVM

# MVC 패턴

애플리케이션 **구조 개선을 위해 관심사의 분리를 활용**하는 아키텍처 디자인 패턴이다.

비즈니스 데이터(모델)와 UI(뷰)를 분리하고, 세 번째 구성 요소(컨트롤러)가 로직과 사용자 입력을 관리하는 구조다.

MVC는 'GoF의 디자인 패턴'에서 설명되어, 대중화되었다.

MVC 패턴은 처음 나타난 이후로 큰 변화를 겪었다.

## Smalltalk-80의 MVC 패턴

- MVC 패턴의 목표로 했던 문제점❓

1970년대에는 GUI라는 것이 거의 존재하지 않았다. 실제 세계의 개념을 모델링하는 도메인 객체와 사용자의 화면에 렌더링되는 프레젠테이션 객체 사이를 명확하게 구분하기 위해 '분리된 프레젠테이션'이라는 개념이 유명해졌다.

Smalltalk-80의 MVC는 이 개념을 한 단계 더 발전시켜 애플리케이션의 로직과 UI를 분리했다. 그렇게 함으로써 애플리케이션의 일부분을 분리해 모델을 애플리케이션의 다른 인터페이스에서도 재사용할 수 있게 되었다.

- 모델: **도메인 관련 데이터 표현**, UI(뷰와 컨트롤러)에는 관여하지 않음. 모델 변경 시 관찰자 객체에게 알림을 보냄.
- 뷰: **모델의 현재 상태를 표현**, 관찰자 패턴으로 모델이 변경되거나 수정되면 뷰가 알아차리게 됨. 뷰는 프레젠테이션 부분만을 담당. 화면에 표시되는 각 섹션, 요소에는 항상 뷰-컨트롤러 쌍이 존재했음.
- 컨트롤러: **사용자의 상호작용을 처리하고 뷰에 무엇을 보여줄지, 사용자의 입력을 어떻게 처리할지 등을 결정**.

모델과 뷰가 상호작용하는 예시로, 주식 데이터가 변경될 때마다 뷰가 즉시 새로 변경되는 주식 시장 데이터 기반 애플리케이션을 들 수 있다.

## 자바스크립트의 MVC

Backbone.js, Ember.js, AngularJS는 대표적인 MVC 패턴의 프레임워크다. 최근에는 리액트, 앵귤러, Vue.js 생태계에서 MV\* 패턴의 다양한 변형 버전을 찾아볼 수 있다.

## 모델

애플리케이션의 데이터를 관리하는 역할이다. 변경 사항이 있으면 관찰자(뷰)에게 알림을 보낸다.

갤러리를 예로 들면, 고유한 도메인 관련 데이터인 '사진'이 독자적인 모델이 될 수 있다.

MV\* 프레임워크에서는 모델을 컬렉션으로 그룹화하기도 한다. 그룹으로 관리하면 그룹 내 특정 모델이 변경될 때 그룹의 알림을 기반으로 애플리케이션 로직을 작성하면 되기 때문에, 개별 모델 인스턴스를 직접 관찰할 필요가 없어진다.

과거 MVC에 대한 자료에서는 모델이 애플리케이션의 상태를 관리한다고 언급되는 경우가 있다. 하지만 자바스크립트 애플리케이션의 '상태'는 다르게 해석되는데, 보통 사용자의 화면에 특정 시점에 나타나는 '상태(특정 데이터를 포함한 뷰 또는 서브 뷰)'를 의미한다.

**모델은 비즈니스 데이터와 주로 관련되어 있다.**

## 뷰

모델에 대한 시각적인 표현으로, 현재 상태의 특정 부분만 보여준다. 모델을 관찰하며, 변화가 있으면 알림을 받아 스스로 업데이트한다.

보통의 자바스크립트의 뷰는 여러 DOM 요소의 집합을 생성하고 정리하는 역할을 한다.

사용자는 뷰와 상호작용한다. 여기에는 모델의 데이터를 읽고 수정(모델의 속성 값을 가져오거나 설정)하는 기능이 포함된다. 갤러리의 경우, 특정 사진의 메타데이터를 편집할 수 있는 '편집 뷰'를 제공함으로써 모델 편집을 용이하게 할 수 있게 한다.

모델을 실제로 업데이트하는 건 컨트롤러가 담당하는 역할이다.

### 템플릿

MV\* 패턴을 지원하는 자바스크립트 프레임워크에서 자주 사용된다. 뷰와 연관이 깊다. 템플릿 자체는 뷰가 아니라 뷰를 생성하는 방법에 불과하다.

문자열 concat으로 메모리에 큰 HTML 마크업 블록을 수동으로 생성하는 것은 성능적으로 나쁘다. 또한 중첩 `div`나 `document.write` 같은 기술로 템플릿을 생성하기도 한다. 이런 방식은 마크업의 가독성을 저하시키고, 유지보수 측면에서 좋지 않은 선택이다.

ES6 이후로는 태그 템플릿 리터럴을 사용한다. 별도의 템플릿 라이브러리 없이 동적인 HTML 콘텐츠를 생성하는 간결하고 유지보수가 용이한 방법을 제공한다.

```JS
// Sample data
const photos = [
  {
    caption: 'Sample Photo 1',
    src: 'photo1.jpg',
    metadata: 'Some metadata for photo 1',
  },
  {
    caption: 'Sample Photo 2',
    src: 'photo2.jpg',
    metadata: 'Some metadata for photo 2',
  },
];

// 태그 템플릿 리터럴을 위한 함수
function photoTemplate(strings, caption, src, metadata) {
  return strings[0] + caption + strings[1] + src + strings[2] + metadata + strings[3];
}

const template = (caption, src, metadata) => photoTemplate`<li class="photo">
  <h2>${caption}</h2>
  <img class="source" src="${src}"/>
  <div class="metadata">
    ${metadata}
  </div>
</li>`;

// 데이터를 돌며 템플릿을 추가
const photoList = document.createElement('ul');
photos.forEach((photo) => {
  const photoItem = template(photo.caption, photo.src, photo.metadata);
  photoList.innerHTML += photoItem;
});

// DOM에 만들어진 템플릿 추가
document.body.appendChild(photoList);
```

💡 해당 방식은 `styled-component`의 컴포넌트를 생성할 때도 쓰이는 문법이다.

## 컨트롤러

## MVC 패턴의 장점

애플리케이션의 기능의 모듈화를 가능하게 한다.

- 유지보수의 단순화: 애플리케이션 업데이트 시 변경사항이 데이터 중심(모델, 컨트롤러의 변경)인지, 단순한 시각적인 변경(뷰의 변경)인지 명확하게 구분할 수 있음
- 모델과 뷰의 분리: 비즈니스 단위에 대한 단위 테스트 작성이 간편해짐
- 하위 수준의 모델 및 컨트롤러 코드 중복 감소
- 모듈화를 통해 코어 로직 개발자와 UI 작업을 담당하는 개발자가 동시에 작업 가능

🌟 최신 자바스크립트 프레임워크는 MVC 패턴을 다양한 요구사항에 맞게 패러다임을 발전시켜 왔다. Smalltalk-80에서의 순수한 MVC 패턴을 자바스크립트로 구현해보고 싶다면 Maria.js라는 라이브러리를 참고할 것.

> 🤔 MVC의 또 다른 관점
>
> GoF는 MVC를 디자인 패턴으로 언급하지 않고 UI를 구축하기 위한 클래스의 집합으로 간주했다. 그들의 관점에서 MVC는 관찰자, 전략, 컴포지트의 세 가지 전통적인 디자인 패턴의 변형이다. 필요 시에는 다른 디자인 패턴들을 사용할 수 있다고 보았다.

💡 새로운 자바스크립트 MVC/MV\* 패턴을 검토할 땐, 프레임워크의 아키텍처 접근 방식을 살펴보자. 특히 모델, 뷰, 컨트롤러 등 요소를 구현하는 방식을 중점적으로 보면 프레임워크의 설계 사상과 장단점, 어떤 프로젝트에 적합할지 명확하게 잘 이해할 수 있다.

# MVP 패턴

프레젠테이션 로직의 개선에 초점을 맞춘 MVC 패턴의 파생형 패턴이다. 두 패턴 모두 관심사 분리를 목표로 하지만, 근본적인 차이점이 존재한다.

## 모델, 뷰, 프리젠터

프리젠터는 뷰에 대한 UI 비즈니스 로직을 담당한다.

MVC 패턴과 달리, 뷰에서의 이벤트 호출이 프리젠터로 위임된다. 프리젠터는 뷰와 분리되어 있고, 인터페이스를 통해 뷰와 통신하게 된다. 해당 방식은 단위 테스트에서 뷰를 모킹할 수 있는 등의 장점을 제공한다.

MVP는 주로 '둔한(passive)' 수동형 뷰를 활용하는 구현 방식을 사용한다. 수동형 뷰는 로직을 거의 갖지 않는다. 프리젠터는 모델을 관찰하고 모델이 변경될 때 뷰를 업데이트한다.

이러한 수동형 아키텍처는 직접적인 데이터 바인딩의 개념이 없고, 뷰는 프리젠터가 데이터를 설정하는 데 사용할 수 있는 세터를 제공한다.

```java
// 1. 계약서(Interface) 정의
interface IUserView {
    void setUserName(String name);
    void showError(String message);
}

// 2. 뷰(View)가 계약서를 구현
class UserProfileView implements IUserView {
    public void setUserName(String name) {
        // 화면에 이름을 표시하는 실제 코드
    }
    public void showError(String message) {
        // 화면에 에러를 표시하는 실제 코드
    }
}

// 3. 프리젠터(Presenter)는 계약서(IUserView)만 보고 소통
class UserPresenter {
    IUserView view; // 어떤 뷰가 오든 상관없음. IUserView 계약만 지키면 됨.

    void display() {
        view.setUserName("홍길동"); // 계약서에 있으니 안심하고 호출
    }
}
```

MVC에 비해 테스트 용이성을 높이고 뷰와 모델 간의 분리를 더욱 명확하게 한다. 하지만, 데이터 바인딩이 지원되지 않아 별도의 처리가 필요한 단점이 존재한다.

> 데이터 바인딩: 모델(또는 뷰모델)의 데이터가 변경되면 뷰(UI)가 자동으로 업데이트되는 기술

MVP의 변형인 감독 컨트롤러(Supervising Controller) 패턴도 있다. 이 패턴은 모델의 데이터를 바로 뷰에 바인딩할 수 있도록 해준다는 점에서 MVC, MVVM 패턴에 더 가깝다.

## MVP vs MVC

두 패턴의 차이점은 의미론적인 수준이다. 근본적인 문제점은 공유할 가능성이 높지만, **모델, 뷰, 컨트롤러(또는 프리젠터)로 관심사를 명확히 분리**하면, 어떤 패턴을 선택하든 동일한 장점을 기대할 수 있다. 실제로 현대 자바스크립트 아키텍처 프레임워크는 전통적인 형태의 MVC, MVP 패턴을 거의 사용하지 않는다.

### MVC

프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 애플리케이션에서 적합하다. 뷰가 복잡하면 여러 컨트롤러에 크게 의존할 가능성이 높다.

### MVP

1. 뷰가 복잡하고 사용자와의 상호작용이 많은 애플리케이션에서 적합하다. 복잡한 로직을 프리젠터 안에 캡슐화할 수 있어 유지보수다 간편해지기 때문이다.
2. MVP의 뷰는 인터페이스를 활용하므로, 개발자가 디자이너가 레이아웃이나 그래픽을 완성하지 않고도 프레젠테이션 로직을 작성할 수 있다.
3. MVC에 비해 단위 테스트가 더 용이할 수 있다. 프리젠터를 UI의 완전한 모킹으로 사용해 다른 구성 요소와 독립적으로 단위 테스트를 할 수 있기 때문이다.

# MVVM 패턴

MVC, MVP를 기반으로 하는 아키텍처 패턴으로, 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리하는 패턴이다. 선언적 데이터 바인딩을 활용해 뷰에 대한 작업을 다른 계층과 분리할 수 있게 한다.

동일 코드베이스 내에서 UI 작업과 개발 작업을 거의 동시에 할 수 있는 장점이 있다.

## 모델

다른 MV\* 패턴과 마찬가지로, 도메인 관련 데이터나 정보를 제공한다. 대표적인 예시는 사용자 계정(이름, 아바타, 이메일), 음악 트랙(제목, 연도, 앨범)를 들 수 있다.

모델은 정보만 담고 동작은 다루지 않는다. 데이터 형식 지정은 뷰, 동작은 뷰모델에서 캡슐화하여 처리한다. 예외적으로 데이터에 대한 유효성 검사는 모델이 담당할 수 있다. (이메일 유효성 검사 등)

## 뷰

MVC와 마찬가지로, 사용자와 상호작용하는 유일한 부분으로 뷰모델의 상태를 표현하는 상호작용 가능한 UI다.

MVVM의 뷰는 다른 패턴에 비해 상대적으로 능동적으로 볼 수 있다. 데이터 바인딩, 이벤트, 동작들을 포함하고 있어 뷰모델에 대한 이해를 필요로 한다. 동작들이 속성에 연결될 수는 있지만, 뷰모델로부터 발생한 이벤트를 처리하는 건 뷰가 한다.

**뷰는 상태 관리에 책임이 없다**. 뷰모델에서 정보 또는 상태를 항상 동기화된 상태로 유지하기 때문이다.

## 뷰모델

모델의 정보를 뷰가 사용할 수 있는 형태로 변환하고, 뷰에서 발생한 명령(사용자의 조작이나 이벤트)을 모델로 전달한다.

**뷰모델은 '모델'에 더 가깝다**. 그러나 동시에 뷰의 디스플레이 로직을 대부분 처리한다. 뷰에서 발생한 동작으로 모델을 업데이트하고, 뷰에 이벤트를 발생시키는 등의 기능을 수행하기 위한 메서드도 제공할 수 있다.

뷰와 뷰모델은 데이터 바인딩과 이벤트를 통해 소통한다. 뷰는 자체 UI 이벤트를 처리하고, 필요에 따라 뷰모델에 매핑한다. 모델과 뷰모델의 속성은 양방향 데이터 바인딩을 통해 동기화되고 업데이트된다.

## MVVM 패턴의 장단점

### 장점

- UI와 로직을 동시에 개발 가능
- 뷰를 추상화해 뷰의 뒤에 작성되는 비즈니스 로직의 양을 줄임
- 뷰모델은 이벤트 중심 코드에 비해 단위 테스트에 용이
- 뷰모델은 UI 자동화나 상호작용에 대한 고려 없이도 테스트 가능 (모델에 가까우므로)

### 단점

- 단순한 UI의 경우, 과도한 구현으로 이어질 수 있음
- 데이터 바인딩은 중단점을 설정하는 명령형 코드에 비해 디버깅이 어려울 수 있음
- 복잡한 애플리케이션에서는 데이터 바인딩이 상당한 관리 부담을 만들 수 있음 (바인딩 코드가 바인딩 객체보다 더 무거워질 수도)
- 대규모 애플리케이션에서는 필요한 일반화를 제공하기 위해 뷰모델을 미리 설계하는 것이 어려울 수 있음 (어떤 기능이 추가될지 예상이 어려움)

# MVC vs MVP vs MVVM

MVC와 파생 패턴들의 차이점은 **각 계층이 다른 계층에 대해 갖는 의존성과, 서로 얼마나 강하게 연결되어 있는지**에 있다.

## MVC 패턴

- 구조: 뷰가 최상단에 있고 그 옆에 컨트롤러가 있다. 모델은 컨트롤러의 아래에 위치한다. 뷰는 컨트롤러에 대해 알지만, 컨트롤러는 모델에 대해 알기 때문에 뷰가 모델에 직접 접근할 수 있다.
- 문제점: 뷰가 전체 모델에 직접 접근하기 때문에, 애플리케이션이 복잡해지면 보안 및 성능에 문제가 발생할 수 있다.

## MVP 패턴

- 구조: MVC의 컨트롤러 역할을 **프리젠터**가 대체한다. 프리젠터는 뷰와 모델 사이의 모든 것을 중개한다.
- 특징: 데이터 바인딩 기능이 없다. 대신 프리젠터는 뷰와 소통하기 위한 인터페이스를 구현하여 상호작용한다.

## MVVM 패턴

- 구조: 뷰에 필요한 데이터와 로직만을 따로 담은 **뷰모델**을 만든다. 이를 통해 전체 모델을 뷰에 노출하지 않아 MVC의 문제를 해결한다.
- 특징: **데이터 바인딩**을 사용한다. 이 덕분에 뷰모델이 뷰를 직접 참조하지 않아도 데이터 동기화가 가능하다. 그리고 뷰의 역할이 선언적으로 바뀌면서(추상화), 뷰 자체에 필요한 로직의 양이 줄어든다.
- 단점: 뷰와 뷰모델을 연결하고 데이터를 변환하는 과정(바인딩)이 복잡해질 수 있다. 이 연결 로직 자체가 성능에 영향을 줄 수 있는 단점이 있다.

# 최신 MV\* 패턴

리액트나 Vue.js는 애플리케이션의 뷰 또는 프레젠테이션 계층을 구성한다. 모델 구현 방식이나 상태 관리에 대해서는 유연하다. Vue.js는 공식적으로 뷰모델을 사용하는 MVVM 패턴이라고 주장한다.

리액트는 MVC 패턴이 아니며, 뷰 계층을 사용자가 원하는대로 구성하게 해주는 렌더링 라이브러리다.

리액트는 MVC를 기술에 따라 수평적으로 나누는 대신, 관심사에 따라 수직적으로 나눈다. 리액트의 컴포넌트는 상태(모델), 렌더링(뷰), 제어 흐름 로직(컨트롤러)을 담고 있는 작은 수직 분할형 MVC로 시작했다고 볼 수 있다.
