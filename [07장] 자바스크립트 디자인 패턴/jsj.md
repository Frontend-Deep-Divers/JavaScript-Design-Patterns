# 7장 자바스크립트 디자인 패턴

## 7.1 생성 패턴

- 생성 패턴은 객체를 생성하는 방법을 다룬다.

## 7.2 생성자 패턴

- 생성자는 객체가 새로 만들어진 뒤 초기화하는데 사용되는 특별한 메서드로 ES2015 버전 이후로 생성자를 가진 클래스를 만들 수 있게 되었다. 이를 통해 기본으로 제공되는 생성자를 통해 클래스의 인스턴스 객체를 생성할 수 있다.
- 객체 생성
    - 자바스크립트에서 객체를 만들때는
        - 리터럴 표기법을 통한 빈 객체 생성
        - Object.create()를 통한 빈 객체 생성
        - new 키워드를 통한 빈 객체 생성
    - 이후 만들어진 객체에 키와 값을 할당할 수 있으며 상속 또한 가능하다.
- 생성자의 기본 특징
    - 클래스는 새 객체를 초기화하는 constructor()라는 이름의 메서드를 가지고 있어야한다.
    - 또한 new 키워드는 생성자를 호출할 수 있으며, 생성자 내부에서 사용된 this 키워드는 새로 생성된 해당 객체를 가리킨다.
- 프로토타입을 가진 생성자
    - 자바스크립트의 프로토타입 객체는 특정 객체의 모든 인스턴스 내에 공통 메서드를 쉽게 정의할 수 있다.
    - 생성자를 통해 객체를 생성하면 생성자의 프로토타입 객체에 속한 속성을 새 객체에서도 활용할 수 있다.

## 7.3 모듈 패턴

- 모듈은 애플리케이션 아키텍처의 핵심 구성 요소이며 프로젝트를 구성하는 코드 단위를 체계적으로 분리 및 관리하는 데 효과적으로 활용된다.
- 객체 리터럴
    - 객체 리터럴 표기법 : 객체는 중괄호안에서 키와 값을 쉼표로 구분하여 객체를 정의하는 방법
    - 선언시 new 연산자를 필요로 하지 않는다.
- 모듈 패턴
    - 클래스의 캡슐화를 위해 처음 고안되었으며, 현재는 자바스크립트 모듈을 사용하여 쉽게 사용이 가능하다.
- 비공개
    - 모듈 패턴은 클로저를 활용해 비공개 상태와 구성을 캡슐화한다. 이는 공개 및 비공개 메서드와 변수를 묶어 전역 스코프로의 유출을 방지하고 다른 개발자의 인터페이스와의 충돌을 예방한다.
    - 선언된 모듈 내부에서만 변수와 메서드를 사용할 수 있으며, 반환되는 객체에 포함된 변수와 메서드는 공개되었기에 다른 곳에서도 사용이 가능하다.
    - 반환된 객체에 포함된 변수를 미공개하려면 WeakMap()을 사용한다.(객체만 키로 설정할 수 있으며 순회가 불가능)
- 모듈 내부의 메서드들을 네임스페이스로 지정하며 포함시키면 다음 이점이 제공된다.
    - 비공개 자유성 : 모듈 내부에서만 사용 가능한 비공개 함수를 자유롭게 만들 수 있다. 다른 파일에서 접근할 수 없기에 완전한 비공개를 실현할 수 있다.
    - 디버깅 용이성 : 어떤 함수가 예외를 발생시켰는지 알아내려고 할 때 디버거에서 콜 스택을 찾기 쉬워진다.
- 모듈 패턴의 변형
    - 믹스인 가져오기 변형
        - 유틸 함수나 외부 라이브러리 같은 전역 스코프에 있는 요소를 모듈 내부의 고차 함수에 인자로 잔달할 수 있게 한다.
    - 내보내기 변형
        - 따로 이름을 지정해주지 않고 전역 스코프로 변수를 내보낸다.
- 장점
    - 캡슐화 개념보다 이해하기 쉽고 비공개를 지원하며, 공개되면 안되는 코드를 캡슐화 할 수 있다.
- 단점
    - 공개와 비공개 멤버를 서로 다르게 접근해야 한다.
    - 나중에 추가된 메서드에서는 비공개 멤버에 접근할 수 없다.
    - 유지보수가 조금 귀찮다.
- WeakMap을 사용한 최신 모듈 패턴
    - (코드 참고)

## 7.4 노출 모듈 패턴

- 모든 함수와 변수를 비공개 스코프에 정의하고 공개하고 싶은 부분만 포인터를 통해 비공개 요소에 접근할 수 있게 하는 익명 객체를 반환하는 패턴
- 장점
    - 코드의 일관성이 유지되고 가독성을 향상 시킴
- 단점
    - 비공개 함수를 참조하는 공개함수를 수정할 수 없다. 비공개 함수가 비공개 구현을 참조하기에 발생하며, 수정을 해도 함수가 변경될 뿐 참조된 구현이 변경되는 것은 아니기 때문..
    - 비공개 변수를 참조하는 공개 객체 멤버 또한 수정이 불가능하다.

## 7.5 싱글톤 패턴

- 클래스의 인스턴스가 오직 하나만 존재하도록 제한하는 패턴
- 전역에서 접근 및 공유해야 하는 단 하나의 객체가 필요할 때 유용하다.
- 초기화를 지연시킬 수 도 있다. 초기화 시점에 필요한 특정 정보가 유효하지 않을 수도 있기 때문
- 단점
    - 싱글톤임을 파악하는 것이 힘들다.
    - 테스트하기 힘들다.
    - 신중한 조정이 필요하다.
- 리액트의 상태관리
    - 리액트에선 싱글톤 대신 전역 상태관리 도구를 이용하여 개발할 수 도 있다. 이들은 싱글톤과는 달리 변경 불가능한 읽기 전용 상태를 제공한다.

## 7.6 프로토타입 패턴

- 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴
- 프로토타입의 상속을 기반으로 하며 프로토타입 역할을 할 전용 객체를 생성하기 된다.
- 장점
    - 다른 언어의 기능을 따라하지 않고 자바스크립트만이 가진 고유의 방식으로 작업할 수 있다.
    - 객체내 함수를 정의할 때 참조로 생성되어 모든 자식 객체가 동일한 함수를 가리키게 할 수 있어 성능 상에서도 이점이 있다.

## 7.7 팩토리 패턴

- 객체를 생성하는 생성 패턴의 하나로, 생성자를 필요로하지 않지만 필요한 타입의 팩토리 객체를 생성하는 다른 방법을 제공함
- 동적인 요소나 애플리케이션 구조에 깊게 의지하는 등의 상황처럼 객체 생성 과정이 복잡할 때 특히 유용하다.
- 유용한 상황
    - 객체나 컴포넌트의 생성과정이 높은 복잡성을 가지고 있을 때
    - 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
    - 같은 속성을 공유하는 여러개의 작은 객체 또는 컴포넌트를 다뤄야 할 때
- 사용하면 안되는 상황
    - 잘못된 상황에 적용하게 되면 애플리케이션의 복잡도가 크게 증가할 수 있다.
    - 객체 생성 인터페이스 제공이 작업 중인 라이브러리가 프레임워크의 설계 목표가 아니라면 생성자를 쓰는 것이 차라리 좋다.
- 추상 팩토리 패턴
    - 같은 목표를 가진 각각의 팩토리를 하나의 그룹으로 캡슐화하는 패턴
    - 객체가 어떻게 생성되는지 알 필요 없이 객체를 사용할 수 있게한다.
    - 객체의 생성 과정에 영향을 받지 않아야하거나 여러 타입의 객체로 작업해야하는 경우에 좋다.

## 7.8 구조 패턴

- 클래스와 객체의 구성을 다룬다.

## 7.9 퍼사드 패턴

- 실제 모습을 숨기고 꾸며낸 겉모습만을 세상에 드러내는 것을 의미하는 퍼사드에서 유래
- 심층적인 복잡성을 숨기고 사용하기 편리한 높은 수준의 인터페이스를 제공하는 패턴
- 클래스의 인터페이스를 단순화하고 코드의 구현 부분과 사용 부분을 분리한다.
- 이를 통해 하위 시스템에 직접 접근하기 보단 간접적으로 상호작용하여 에러를 줄일 수 있다.
- 사용하기 쉬우며 패턴 구현에 필요한 코드의 양이 적다는 장점이 있다.

## 7.10 믹스인 패턴

- C++, Lisp 같은 전통적인 프로그래밍 언어에서 믹스인은 서브클래스가 쉽게 상속받아 기능을 재사용할 수 있도록 하는 클래스

## 7.11 서브 클래싱

- 부모 클래스 객체에서 속성을 상속받아 새로운 객체를 만드는 것
- 서브 클래스는 부모 클래스에서 먼저 정의된 메서드를 오버라이드 하는 것도 가능하다.
- 오버라이드된 부모 클래스의 메서드를 호출하면 메서드 체이닝, 생성자를 호출하면 생성자 체이닝이라고 부른다.

## 7.12 믹스인

- 자바스크립트에서는 기능의 확장을 위해 믹스인의 상속을 이용한다. 새롭게 만들어지는 클래스는 부모 클래스로부터 메서드와 속성을 부여받는다. 또한 자신만의 속성과 메서드를 정의할 수도 있다.
- 믹스인은 최소한의 복잡성으로 객체의 기능을 빌리거나 상속할 수 있게 해준다. 다른 여러 클래스를 아울러 쉽게 공유할 수 있는 속성과 메서드를 가진 클래스이다.
- 이를 통해 자바 스크립트의 클래스는 부모 클래스를 하나만 가질 수 있지만 여러 클래스의 기능을 섞는 것으로 문제를 해결할 수 있다.
- 부모 클래스를 받아 새로운 서브클래스를 만들어내는 믹스인 함수를 정의할 수 있다.
- 장점
    - 함수의 중복을 줄이고 재사용성을 높인다.
    - 애플리케이션에서 객체 인스턴스 사이에 공유되는 기능이 있다면 믹스인을 통해 기능을 공유하여 중복을 피하고 고유 기능을 구현하는 데 집중할 수 있다.
- 단점
    - 클래스나 객체의 프로토타입에 기능을 주입하게 되면 프로토타입 오염과 함수의 출처에 대한 불확실성을 초래하게 된다.

## 7.13 데코레이터 패턴

- 코드 재사용을 목표로 하는 구조 패턴. 믹스인과 마찬가지로 객체 서브 클래싱의 다른 방법이다.
- 기본적으로 기존 클래스에 동적으로 기능을 추가하기 위해 사용하며 내부코드를 바꾸지 않고도 기능을 추가할 수 있다.
- 새로운 객체를 생성하는 것이 아닌 기능의 확장에 초점을 두어 프로토토 타입의 상속에 의지하는 것이 아닌 하나의 베이스 클래스에 추가 가능을 제공하는 데코레이터 객체를 점진적으로 추가한다.

## 7.14 의사 클래스 데코레이터

- ‘인터페이스’ 개념을 사용하여 데코레이터가 다른 프로그래밍 언어(java, C++)등에서 어떻게 구현되는지에 초점을 둠
- 인터페이스
    - 데코레이터 패턴 : 같은 인터페이스를 가진 서로 다른 객체 내부에 새 객체를 넣어서 사용하는 방법
    - 인터페이스 : 객체가 가져야할 메서드를 정의하는 방법
    - 인터페이스를 통해 재사용성을 높이고 코드의 안정성을 높인다.
- 추상 데코레이터
    - 인터페이스를 구현하기 위해 필요한 기본 메서드를 정의하고 나머지 옵션을 서브 클래스로 함으로써 모든 가능한 조합의 클래스를 따로 정의하지 않고도, 필요한 만큼의 데코레이터만을 사용하여 베이스 클래스에 독립적으로 기능을 추가할 수 있게 해준다.
    - 많은 서브 클래스를 관리하기 편하게 해준다.

## 7.15 장점과 단점

- 데코레이터 패턴의 장점
    - 우연하고 투명하게 사용될 수 있는 디자인 패턴
    - 데코레이터 패턴의 객체는 새로운 기능으로 감싸져 확장되거나 ‘데코레이트’될 수 있다.
    - 베이스 객체가 변경될 걱정 없이 사용될 수 있다.
    - 수많은 서브 클래스에 의존할 필요도 없다.
- 주의할 점
    - 네임 스페이스에 작고 비슷한 객체를 추가하기 때문에 잘 관리하지 못하면 구조가 복잡해진다.
    - 관리가 힘들다.

## 7.16 플라이웨이트 패턴

- 반복되고 느리고 비효율적으로 데이터를 공유하는 코드를 최적화하는 전통적인 구조적 해결법
- 연관된 객체끼리 데이터를 공유하게 하면서 애플리케이션의 메모리를 최소화하는 목적을 가지고 있다.
- 패턴의 목표가 메모리 공간의 경량화이며, 여러 비슷한 객체나 데이터 구조에서 공통으로 사용되는 부분만을 하나의 외부 객체로 내보내어 데이터를 공유한다.
- 사용법
    - 데이터 레이어에서 메모리에 저장된 수많은 비슷한 객체 사이로 데이터를 공유
    - DOM 레이어에도 플라이웨이트를 적용할 수 있음 (비슷한 동작을 하는 이벤트 핸들러를 모든 자식 요소에 등록하기 보다는 부모 요소 같은 중앙 이벤트 관리자에게 맡기는 등)
- 데이터 공유
    - 내재적 정보 : 객체의 내부 메서드에 필요하며 없으면 절대로 동작하지 않는다.
    - 외재적 정보 : 제거되어 외부에 저장될 수 있다.
    - 같은 내재적 정보를 지닌 객체를 팩토리 메서드를 사용해 만들어진 하나의 공유된 객체로 대체할 수 있다. 이를 통해 저장된 내부 데이터의 양을 상당히 줄일 수 있다.
    - 외재적 정보를 다룰 때는 따로 관리자를 사용한다.

## 7.17 행위 패턴

- 객체간의 의사소통을 돕는 패턴. 시스템 내 서로 다른 객체 간의 의사소통 방식을 개선하고 간소화하는 것을 목적으로 합니다.

## 7.18 관찰자 패턴

- 한 객체가 변경될 때 다른 객체들에 변경되었음을 알릴 수 있게 해주는 패턴
- 변경된 객체는 누가 자신을 구독하는지 알 필요 없이 알림을 보낼 수 있다.
- 한 객체를 관찰하는 여러 객체들이 존재하며, 주체의 상태가 변화하면 관찰자들에게 자동으로 알림을 보낸다.
- 주체가 관찰자에게 중요한 변경사항을 알려야할 때, 변경에 대한 알림과 함께 관련 정보를 모든 관찰자에게 전달합니다.
- 구성 요소
    - 주체 : 관찰자 리스트를 관리하고, 추가와 삭제를 가능하게 합니다.
    - 관찰자 : 주체의 상태 변화 알림을 감지하는 update 인터페이스를 제공합니다.
    - 구체적 주체 : 상태 변화에 대한 알림을 모든 관찰자에게 전달하고, 구체적 관찰자의 상태를 저장한다.
    - 구체적 관찰자 : 구체적 주체의 참조를 저장하고, 관찰자의 update 인터페이스를 구현하여 주체의 상태 변화와 관찰자의 상태 변화가 일치할 수  있도록 한다.
- 관찰자 패턴과 발행/구독 패턴의 차이점
    - 관찰자 패턴에서는 이벤트 발생에 대해 알림 받기를 원하는 관찰자 객체가 이벤트를 발생시키는 주체 객체에 알림 대상으로서 등록되어야 한다.
    - 발행/구독 패턴에서는 이벤트 알림을 원하는 구독자와 이벤트를 발생시키는 발행자 사이에 토픽/이벤트 채널을 둔다. 이를 통해 애플리케이션에 특화된 이벤트를 정의할 수 있고, 구독자에게 필요한 값이 포함된 커스텀 인자를 전달할 수 있다. 발생/구독 패턴의 핵심은 발행자와 구독자를 각자 독립적으로 유지한다는 것이다.
- 장점
    - 주체와 객체 사이에 동적인 관계가 형성되며 이를 통해 애플리케이션의 여러 부분이 강하게 결합되어 있을 때 구현하기 까다로운 뛰어난 유연성을 쉽게 구현할 수 있다.
- 단점
    - 발행자와 구독자의 연결을 분리했기에, 애플리케이션의 특정 부분들이 기대하는 대로 동작하고 있다는 것을 보장하기 어려워질 수 도 있다.
    - 구독자들이 서로의 존재에 대해 전혀 알 수 없고 발행자를 변경하는 데 드는 비용을 파악할 수 없다.

## 7.19 중재자 패턴

- 하나의 객체가 이벤트 발생 시 다른 여러 객체들에게 알림을 보낼 수 있는 디자인 패턴
- 하나의 객체가 다른 객체에서 발생한 특정 유형의 이벤트에 대해 알림을 받을 수 있다.
(이벤트 집합, 발행/구독 패턴 : 여러개의 이벤트 소스를 하나의 객체로 보내는 방법)
- 구성 요소간의 관계를 관리함으로써 직접 참조를 없애고 느슨한 결합을 가능하게 한다. 이는 시스템의 결합도를 낮추고 구성 요소의 재사용성을 높여준다.
- 유사점과 차이점
    - 중재자 패턴과 이벤트 집합 패턴의 예시에는 유사한 점이 있다.
    - 이벤트
        - 이벤트 집합 패턴과 중재자 패턴 모두 이벤트를 사용한다.
        - 이벤트 집합 패턴은 그 자체로 이벤트를 처리하기 위한 목적으로 설계된 패턴이다.
        - 중재자 패턴은 그 자체로 이벤트를 처리하기 위한 목적으로 설계된 패턴이다.
    - 서드파티 객체
        - 이벤트 집합 패턴과 중재자 패턴 모두 상호작용을 간소화하기 위해 서드 파티 객체를 사용한다.
        - 이벤트 집합 패턴 자체는 이벤트 발행자와 구독자에 대해 서드 파티 객체이며, 모든 이벤트가 통과하는 중앙 허브의 역할을 한다.
        - 중재자 패턴 또한 다른 객체에 대한 서드 파티 객체다.
        - 둘의 차이는 애플리케이션 로직과 워크플로가 어디에 구현되어 있는지에 달려있다.
        - 이벤트 집합 패턴에서 서드 파티 객체는 알 수 없는 수의 소스에서 알 수 없는 수의 핸들러로 이벤트가 연결되도록 지원하는 역할만 한다. 실행되어야 하는 모든 워크플로와 비즈니스 로직은 이벤트를 발생시키는 객체와 처리하는 객체에 직접 구현된다.
        - 중재자 패턴에는 비즈니스 로직과 워크플로는 중재자 내부에 집중된다.
- 이벤트 집합 패턴의 활용
    - 직접적인 구독 관계가 많아질 경우 또는 전혀 관련 없는 객체들간의 소통이 필요할 때 사용된다.
    - 간접적인 관계를 가진 객체 간의 소통이 필요한 상황에서도 유용하게 활용된다.
- 중재자 패턴의 활용
    - 중재자 패턴은 두 개 이상의 객체가 간접적인 관계를 가지고 있고 비즈니스 로직이나 워크플로에 따라 상호작용 및 조정이 필요한 경우에 유용하다.
- 중재자 패턴 vs 퍼사드 패턴
    - 중재자 패턴은 모듈이 명시적으로 중재자를 참조함으로써 모듈간의 상오작용을 중앙집중화한다. 이는 본질적으로 다방향성을 지닌다.
    - 퍼사드 패턴은 모듈 또는 시스템에 직관적인 인터페이스를 제공하지만 추가 기능을 구현하지는 않는다. 시스템 내 다른 모듈은 퍼사드의 개념을 직접적으로 인지하지 못하므로 단방향성을 지닌다.

## 7.20 커맨드 패턴

- 메서드 호출, 요청 또는 작업을 단일 객체로 캡슐화하여 추후에 실행할 수 있도록 해준다. 이를 통해 실행 시점을 유연하게 조정하고 호출을 매개변수화할 수 도 있다.
- 커맨드 패턴은 명령을 실행하는 객체와 명령을 호출하는 객체 간의 결합을 느슨하게 하여 구체적인 클래스(객체)의 변경에 대한 유연성을 향상시킨다.
- 구체 클래스는 클래스 기반 프로그래밍 언어에서 중요한 개념으로, 추상 클래스와도 연관이 있다. 추상 클래스는 인터페이스를 제공하지만 모든 멤버 함수의 구현을 제공하지는 않는다.
- 추상 클래스는 상속을 통해 구체화되는 기초 클래스의 역할을 한다. 이렇게 추상 클래스를 상속받아 필요한 기능을 모두 구현한 클래스를 구체 클래스라고 한다.
- 커맨드 패턴의 기본 원칙은 명령을 내리는 객체와 명령을 실행하는 객체의 책임을 분리한다는 것이다. 커맨드 패턴은 이러한 책임을 다른 객체에 위임함으로써 역할 분리를 실현한다.분리