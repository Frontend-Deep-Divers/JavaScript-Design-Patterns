# 10장 모듈형 자바스크립트 디자인 패턴

## 10.1 스크립트 로더에 대한 참고 사항

- 스크립터 로더 : 모듈형 자바스크립트를 구현하기 위한 핵심적인 도구로, 호환 가능한 스크립트 로더를 사용해야 모듈형 자바스크립트를 구현할 수 있다.

## 10.2 AMD

- AMD 모듈 형식은 모듈과 의존성 모두를 비동기적으로 로드할 수 있게 설계된 모듈 정의 방식이다. 이러한 AMD 형식의 주요 목표는 개발자들이 활용할 수 있는 모듈형 자바스크립트 솔루션을 제공하는 것이다.
- AMD 형식은 비동기적이면서도 높은 유연성을 가지고 있어, 코드와 모듈간 결합을 줄여주는 등의 장점을 가지고 있다.
- 모듈 알아보기
    - 모듈을 정의하는 define 메서드와 의존성 로딩을 처리하는 require 메서드로 나뉜다.
    - define 메서드는 이름이 있는 모듈 혹은 익명 모듈을 정의하는데 사용된다.
        
        ```jsx
        define(
        	module_id //선택인자
        	[dependencies] //선택인자
        	definition function {} 
        );
        ```
        
        여기서 module_id를 생략하면 해당 모듈을 익명 모듈이라고 부른다.
        
    - 익명 모듈을 사용할 때, 파일명과 코드의 중복을 최소화할 수 있다. 이렇게 만들어진 익명 모듈은 코드의 재사용성이 높기 때문에, 코드 내용이나 모듈 ID를 변경하지 않고도 다른 영역으로 손쉽게 이동할 수 있다.
    - dependencies 인자는 우리가 정의하고 있는 모듈에서 필요로 하는 의존성 배열을 나타낸다.
    - 세 번째 인자는 모듈을 초기화하기 위해 실행되는 함수다.
    - require는 일반적으로 최상위 자바스크립트 파일이나 모듈 내에서 의존성을 동적으로 가져오고자 할 때 사용된다.
- AMD 모듈과 jQuery
    - AMD가 모듈형 자바스크립트 작성에 더 좋은 이유
        - 유연한 모듈 정의 방식에 대한 명확한 제안을 제공한다.
        - 기존에 많이 사용되고 있는 전역 네임스페이스나 <script> 태그 방식에 비해 훨씬 더 구조화되어 있다.
        - 모듈 정의가 독립적으로 이루어지기 때문에 전역 네임스페이스의 오염을 방지할 수 있다.
        - 등등..
- AMD에 대한 결론
    - AMD는 전역 객체의 사용에 대한 걱정을 줄여주고, 변수에 모듈을 할당할 수 있게 해주고, 브라우저 환경의 모듈 작동을 위해 서버 사이드에서의 변환이 따로 필요하지 않으며, 의존성 관리 측면에서 매우 효율적이다.

## 10.3 CommonJS

- 서버 사이드에서 모듈을 선언하는 간단한 API를 지정하는 모듈 제안. AMD와는 달리 I/O, 파일 시스템, 프로미스 등 더욱 광범위한 부분을 다룬다.
- 구조적 관점에서 볼 때, CommonJS 모듈은 재사용 가능한 자바스크립트 코드로써 외부 의존 코드에 공개할 특정 객체를 내보낸다.
- AMD와 달리 CommonJS는 모듈을 함수로 감싸는 작업이 필요하지는 않다.
- 두가지 핵심 요소로 구성되며, exports 변수는 다른 모듈에 내보내고자 하는 객체를 담는다. require 함수는 다른 모듈에서 내보낸 객체를 가져올 때 사용하는 함수다.
- Node.js 환경에서의 CommonJS
    - ES모듈 형식이 자바스크립트 코드를 모듈화하는 표준으로 자리잡았지만, Node.js 환경에선 CommonJS가 기본으로 쓰인다.(최근은 ES 모듈도 지원)
    - Node.js는 다음과 같은 파일들을 CommonJS 모듈로 인식한다.
        - .cjs 확장자를 가진 파일
        - 가장 가까이에 위차한 package.json 파일 안에 type 항목의 값이 commonjs로 되어있는 경우, .js 확장자를 가진 파일
        - 등등..

## 10.4 AMD vs CommonJS : 동상이몽

- AMD는 브라우저 우선 접근 방식을 채택하여 비동기 동작과 간소화된 하위 호환성을 선택한 반면, 파일 I/O에 대한 개념은 없다. 또한 객체, 함수, 생성자, 문자열, JSON 등 다양한 형태의 모듈을 지원하며 브라우저에서 자체적으로 실행된다는 면에서 대단히 유연한 포맷이다.
- CommonJS는 서버 우선 접근 방식을 취하며 동기적 작동, 전역 변수와의 독립성 그리고 미래의 서버 환경을 고려한다.