# 10장 모듈형 자바스크립트 디자인 패턴

모듈형이란 서로 의존성이 낮은 기능들이 모듈로써 저장된 형태를 말한다. 느슨한 결합은 의존성을 제거하여 유지보수성을 높인다.

> 스크립트 로더: AMD나 CJS 같은 모듈형 자바스크립트를 위한 도구로, RequireJS, curl.js 등이 있다.

# AMD

Asynchronous Module Definition로, 모듈과 의존성을 비동기적으로 로드할 수 있게 설계된 모듈 정의 방식이다.

CJS의 사양 초안으로 시작했으나, 도입에 합의점을 이루지 못해 추가 개발은 amdjs 그룹이 진행했다.

가장 중요한 개념은, 모듈 정의를 위한 `define` 메서드와 의존성 로딩을 위한 `require` 메서드이다.

## AMD를 사용하는 게 왜 단순한 모듈 패턴보다 좋을까?

- 모듈 정의 방식에 대한 명확한 제안을 제공
- 전역 네임스페이스나 `script` 태그에 비해 구조화되어 있음
- 모듈 정의로써 전역 네임스페이스 오염 방지
- 여러 모듈을 하나의 파일로 가져오기 위해 '전송' 방식을 제공하고 있고, 이는 CJS는 도입하지 못하고 있음. (병렬적으로 모듈 로딩이 가능)
- 스크립트의 지연 로딩을 지원

# CommonJS

서버 사이드에서 모듈을 선언하는 간단한 API를 지정하는 모듈 제안이다. AMD와 달리 I/O, 파일 시스템, 프로미스 등 넓은 부분을 다룬다.

CJS는 외부 의존 코드에 공개할 특정 객체를 내보내는 방식을 사용한다.

핵심 요소 두 가지로 구성된다. `exports` 변수로 다른 모듈에 내보내는 객체를 담고, `require` 함수로 다른 모듈에서 보낸 객체를 사용한다.

## 브라우저 환경에 적합할까?

ESM이나 AMD 모듈은 생성자나 함수를 더 세밀하게 정의할 수 있지만, CJS는 오직 객체만을 정의할 수 있기에 생성자를 정의하는 경우 번거로울 수 있다.

현재 Node.js는 ESM도 지원하므로 클라이언트와 서버 사의 사용 방법의 차이가 없어서 브라우저와 서버 상관없이 동형으로 구현하기 쉬워졌다.

# AMD vs CJS

AMD는 브라우저 우선 접근 방식을 택했다. 비동기 동작과 간소화된 하위 호환성을 선택했으며, 파일 I/O에 대한 개념이 없다. 브라우저에서 자체적으로 실행될 수 있다.

CJS는 서버 우선 접근 방식을 택했다. 동기적 작동, 전역 변수와의 독립성, 미래의 서버 환경을 고려한다. (함수로 래핑할 필요가 없어 ES2015+ 표준에 더 가깝게 느껴질 수 있다는 의미)

# UMD

Universal Module Definition으로, AMD와 CJS의 절충안으로 만들어진 모듈 포맷이다.

```js
(function (root, factory) {
  if (typeof exports === "object") {
    // CommonJS 방식인 경우
    factory(exports, require("b"));
  } else if (typeof define === "function" && define.amd) {
    // AMD 방식인 경우. 익명 모듈로 등록합니다.
    define(["exports", "b"], factory);
  } else {
    // 브라우저 전역 변수 사용의 경우
    factory((root.commonJsStrict = {}), root.b);
  }
})(this, function (exports, b) {
  // 'b' 모듈에 정의된 항목들을 사용할 수 있습니다.

  // exports 객체에 추가된 프로퍼티나 메서드가 이 모듈에서 제공됩니다.
  exports.action = function () {};
});
```
